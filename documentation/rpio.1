.TH "RPIO" "1" "February 27, 2013" "0.8.2" "RPIO"
.SH NAME
rpio \- RPIO Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructuredText.
.
.sp
RPIO is a GPIO toolbox for the Raspberry Pi.
.INDENT 0.0
.IP \(bu 2
\fI\%RPIO.py\fP, an extension of \fI\%RPi.GPIO\fP with interrupt handling, socket servers and \fI\%more\fP
.IP \(bu 2
\fI\%rpio\fP, a command\-line multitool for inspecting and manipulating GPIOs system\-wide
.UNINDENT
.sp
\fBNew\fP
.INDENT 0.0
.IP \(bu 2
Socket server callbacks with \fI\%RPIO.add_tcp_callback(port, callback, threaded_callback=False))\fP
.UNINDENT
.sp
The easiest way to install/update RPIO on a Raspberry Pi is with either \fBeasy_install\fP or \fBpip\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo apt\-get install python\-setuptools
$ sudo easy_install \-U RPIO
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Another way to get RPIO is directly from the Github repository (make sure you have \fBpython\-dev\fP installed):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone https://github.com/metachris/RPIO.git
$ cd RPIO
$ sudo python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the installation you can use import \fBRPIO\fP as well as the command\-line tool \fBrpio\fP.
.sp
\fBrpio\fP allows you to inspect and manipulate GPIO\(aqs system wide, including those used by other processes.
\fBrpio\fP needs to run with superuser privileges (root), else it will restart using \fBsudo\fP. The BCM GPIO numbering
scheme is used by default.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Show the help page:

    $ rpio \-h

Inspect the function and state of gpios (with \-i/\-\-inspect):

    $ rpio \-i 7
    $ rpio \-i 7,8,9
    $ rpio \-i 1\-9

    # Example output for \(garpio \-i 1\-9\(ga (non\-existing are ommitted):
    GPIO 2: ALT0   (1)
    GPIO 3: ALT0   (1)
    GPIO 4: INPUT  (0)
    GPIO 7: OUTPUT (0)
    GPIO 8: INPUT  (1)
    GPIO 9: INPUT  (0)

Inspect all GPIO\(aqs on this board (with \-I/\-\-inspect\-all):

    $ rpio \-I

Set GPIO 7 output to \(ga1\(ga (or \(ga0\(ga) (with \-s/\-\-set):

    $ rpio \-s 7:1

    You can only write to pins that have been set up as OUTPUT. You can
    set this yourself with \(ga\-\-setoutput <gpio\-id>\(ga.

Wait for interrupt events on GPIOs (with \-w/\-\-wait_for_interrupts). You
can specify an edge (eg. \(ga:rising\(ga; default=\(aqboth\(aq) as well as \(ga:pullup\(ga,
\(ga:pulldown\(ga or \(gapulloff\(ga.

    $ rpio \-w 7
    $ rpio \-w 7:rising
    $ rpio \-w 7:falling:pullup

    $ rpio \-w 7:rising:pullup,17,18
    $ rpio \-w 1\-9

Setup a pin as INPUT (optionally with software resistor):

    $ rpio \-\-setinput 7
    $ rpio \-\-setinput 7:pullup
    $ rpio \-\-setinput 7:pulldown

Setup a pin as OUTPUT (optionally with an initial value (0 or 1)):

    $ rpio \-\-setoutput 8
    $ rpio \-\-setoutput 8:1

Show Raspberry Pi system info:

    $ rpio \-\-sysinfo

    # Example output:
    Model B, Revision 2.0, RAM: 256 MB, Maker: Sony
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can update the \fBRPIO\fP package to the latest version:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ rpio \-\-update\-rpio
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Install (and update) the \fBrpio\fP manpage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ rpio \-\-update\-man
$ man rpio
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
RPIO.py extends \fI\%RPi.GPIO\fP with
various methods, and uses the BCM GPIO numbering scheme by default.
.INDENT 0.0
.IP \(bu 2
\fI\%GPIO Input & Output\fP
.IP \(bu 2
\fI\%Interrupt handling\fP
.IP \(bu 2
\fI\%Socket servers\fP
.IP \(bu 2
\fI\%more\fP.
.UNINDENT
.SH GPIO INTERRUPTS
.sp
Interrupts are used to receive notifications from the kernel when GPIO state
changes occur. Advantages include minimized cpu consumption, very fast
notification times, and the ability to trigger on specific edge transitions
(\fBrising\fP, \fBfalling\fP or \fBboth\fP). You can also set a software pull\-up
or pull\-down resistor.
.INDENT 0.0
.TP
.B RPIO.add_interrupt_callback(gpio_id, callback, edge=\(aqboth\(aq, pull_up_down=RPIO.PUD_OFF, threaded_callback=False)
Adds a callback to receive notifications when a GPIO changes it\(aqs value.. Possible edges are \fBrising\fP,
\fBfalling\fP and \fBboth\fP (default). Possible \fBpull_up_down\fP values are \fBRPIO.PUD_UP\fP, \fBRPIO.PUD_DOWN\fP and
\fBRPIO.PUD_OFF\fP (default)
.UNINDENT
.SH TCP SOCKET INTERRUPTS
.sp
RPIO makes it easy to open ports for incoming TCP connections with \fBadd_tcp_callback(port, callback, threaded_callback=False)\fP.
When \fBRPIO.wait_for_interrupts()\fP is running, you can connect to the socket server with \fB$ telnet localhost <your\-port>\fP.
.INDENT 0.0
.TP
.B RPIO.add_tcp_callback(port, callback, threaded_callback=False)
Adds a socket server callback, which will be started when a connected socket client sends something. This is implemented
by RPIO creating a TCP server socket at the specified port. Incoming connections will be accepted when \fBRPIO.wait_for_interrupts()\fP runs.
The callback must accept exactly two parameters: server and message (eg. \fBdef callback(socket, msg)\fP). The callback can use the socket parameter to send values back to the client (eg. \fBsocket.send("hi there\en")\fP).
.UNINDENT
.SH EXAMPLE
.sp
The following example shows how to react to events on three gpios, and one socket
server on port 8080:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO

def gpio_callback(gpio_id, val):
    print("gpio %s: %s" % (gpio_id, val))

def socket_callback(socket, val):
    print("socket %s: \(aq%s\(aq" % (socket.fileno(), val))
    socket.send("echo: %s\en" % val)

def do_something(gpio_id, value):
    logging.info("New value for GPIO %s: %s" % (gpio_id, value))

# Three GPIO interrupt callbacks
RPIO.add_interrupt_callback(7, gpio_callback)
RPIO.add_interrupt_callback(8, gpio_callback, edge=\(aqrising\(aq)
RPIO.add_interrupt_callback(9, gpio_callback, pull_up_down=RPIO.PUD_UP)

# One TCP socket server callback on port 8080
RPIO.add_tcp_callback(8080, socket_callback)

# Start the blocking epoll loop
RPIO.wait_for_interrupts()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Now you can connect to the socket server with \fB$ telnet localhost 8080\fP and
everything you send to the callback will be echoed by the \fBsocket.send(..)\fP command.
If you want to receive a callback inside a Thread (which won\(aqt block anything
else on the system), set \fBthreaded_callback\fP to \fBTrue\fP when adding an interrupt\-
callback. Here is an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# for GPIO interrupts
RPIO.add_interrupt_callback(7, do_something, threaded_callback=True)

# for socket interrupts
RPIO.add_tcp_callback(8080, socket_callback, threaded_callback=True))
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To stop the \fBwait_for_interrupts()\fP loop you can call \fBRPIO.stop_waiting_for_interrupts()\fP.
If an exception occurs while waiting for interrupts, all interfaces will be cleaned and reset,
and you need to re\-add callbacks before waiting for interrupts again. If you use \fBRPIO.stop_waiting_for_interrupts()\fP.
you should call \fBRPIO.cleanup()\fP before your program exits.
.SH GPIO INPUT & OUTPUT
.sp
RPIO extends \fI\%RPi.GPIO\fP;
all the input and output handling works just the same:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO

# set up input channel without pull\-up
RPIO.setup(7, RPIO.IN)

# set up input channel with pull\-up control. Can be
# PUD_UP, PUD_DOWN or PUD_OFF (default)
RPIO.setup(7, RPIO.IN, pull_up_down=RPIO.PUD_UP)

# read input from gpio 7
input_value = RPIO.input(7)

# set up GPIO output channel
RPIO.setup(8, RPIO.OUT)

# set gpio 8 to high
RPIO.output(8, True)

# set up output channel with an initial state
RPIO.setup(8, RPIO.OUT, initial=RPIO.LOW)

# change to BOARD numbering schema
RPIO.setmode(RPIO.BOARD)

# set software pullup on channel 17
RPIO.set_pullupdn(17, RPIO.PUD_UP)

# reset every channel that has been set up by this program,
# and unexport interrupt gpio interfaces
RPIO.cleanup()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can use RPIO as a drop\-in replacement for RPi.GPIO in your existing code like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO as GPIO  # (if you\(aqve previously used \(gaimport RPi.GPIO as GPIO\(ga)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To find out more about the methods and constants in RPIO you can run \fB$ sudo pydoc RPIO\fP, or
use the help method inside Python:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO
help(RPIO)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH ADDITIONS TO RPI.GPIO
.sp
Additional Constants
.INDENT 0.0
.IP \(bu 2
\fBRPIO.RPI_REVISION\fP (either \fB1\fP or \fB2\fP)
.IP \(bu 2
\fBRPIO.RPI_REVISION_HEX\fP (\fB0002\fP .. \fB000f\fP)
.UNINDENT
.sp
Additional Methods
.INDENT 0.0
.IP \(bu 2
\fBRPIO.gpio_function(gpio_id)\fP \- returns the current setup of a gpio (\fBIN, OUT, ALT0\fP)
.IP \(bu 2
\fBRPIO.set_pullupdn(gpio_id, pud)\fP \- set a pullup or \-down resistor on a GPIO
.IP \(bu 2
\fBRPIO.forceinput(gpio_id)\fP \- reads the value of any gpio without needing to call setup() first
.IP \(bu 2
\fBRPIO.forceoutput(gpio_id, value)\fP \- writes a value to any gpio without needing to call setup() first
(\fBwarning\fP: this can potentially harm your Raspberry)
.IP \(bu 2
\fBRPIO.rpi_sysinfo()\fP \- returns \fB(model, revision, mb\-ram and maker)\fP of this Raspberry
.UNINDENT
.sp
Interrupt Handling
.INDENT 0.0
.IP \(bu 2
\fBRPIO.add_interrupt_callback(gpio_id, callback, edge=\(aqboth\(aq, pull_up_down=RPIO.PUD_OFF, threaded_callback=False)\fP
.IP \(bu 2
\fBRPIO.add_tcp_callback(port, callback, threaded_callback=False)\fP
.IP \(bu 2
\fBRPIO.del_interrupt_callback(gpio_id)\fP
.IP \(bu 2
\fBRPIO.wait_for_interrupts(epoll_timeout=1)\fP
.IP \(bu 2
\fBRPIO.stop_waiting_for_interrupts()\fP
.IP \(bu 2
implemented with \fBepoll\fP
.UNINDENT
.sp
Other Changes
.INDENT 0.0
.IP \(bu 2
Uses \fBBCM\fP GPIO numbering by default
.IP \(bu 2
Improved documentation
.IP \(bu 2
Refactored, clean, simple C GPIO library
.IP \(bu 2
Interrupt handling
.IP \(bu 2
Support for P5 header GPIOs (29\-31) [??]
.IP \(bu 2
Command\-line tool \fBrpio\fP
.UNINDENT
.sp
Please send feedback and ideas to \fI\%chris@linuxuser.at\fP, and \fI\%open an issue at Github\fP if
you\(aqve encountered a bug.
.sp
\fBHow does RPIO work?\fP
.INDENT 0.0
.INDENT 3.5
RPIO extends RPi.GPIO, a GPIO controller written in C which uses a low\-level memory interface. Interrupts are
implemented  with \fBepoll\fP via \fB/sys/class/gpio/\fP. For more detailled information take a look at the \fI\%source\fP, it\(aqs well documented and easy to build.
.UNINDENT
.UNINDENT
.sp
\fBShould I update RPIO often?\fP
.INDENT 0.0
.INDENT 3.5
Yes, because RPIO is getting better by the day. You can use \fB$ rpio \-\-update\-rpio\fP or see \fI\%Installation\fP for more information about methods to update.
.UNINDENT
.UNINDENT
.sp
\fBI\(aqve encountered a bug, what next?\fP
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Make sure you are using the latest version of RPIO (see \fI\%Installation\fP)
.IP \(bu 2
Open an issue at Github
.INDENT 2.0
.IP \(bu 2
Go to \fI\%https://github.com/metachris/RPIO/issues/new\fP
.IP \(bu 2
Describe the problem and steps to replicate
.IP \(bu 2
Add the output of \fB$ rpio \-\-version\fP and \fB$ rpio \-\-sysinfo\fP
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBpip is throwing an error during the build:\fP \fBsource/c_gpio/py_gpio.c:9:20: fatal error: Python.h: No such file or directory\fP
.INDENT 0.0
.INDENT 3.5
You need to install the \fBpython\-dev\fP package (eg. \fB$ sudo apt\-get install python\-dev\fP), or use \fBeasy_install\fP (see \fI\%Installation\fP).
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fI\%https://github.com/metachris/RPIO\fP
.IP \(bu 2
\fI\%http://pypi.python.org/pypi/RPIO\fP
.IP \(bu 2
\fI\%http://pypi.python.org/pypi/RPi.GPIO\fP
.IP \(bu 2
\fI\%http://www.kernel.org/doc/Documentation/gpio.txt\fP
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
RPIO is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RPIO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
v0.8.2
.INDENT 2.0
.IP \(bu 2
Added TCP socket callbacks
.UNINDENT
.IP \(bu 2
v0.8.0
.INDENT 2.0
.IP \(bu 2
Improved auto\-cleaning of interrupt interfaces
.IP \(bu 2
BOARD numbering scheme support for interrupts
.IP \(bu 2
Support for software pullup and \-down resistor with interrupts
.IP \(bu 2
New method \fBRPIO.set_pullupdn(..)\fP
.IP \(bu 2
\fBrpio\fP now supports P5 header gpios (28, 29, 30, 31) (only in BCM mode)
.IP \(bu 2
Tests added in \fBsource/run_tests.py\fP and \fBfabfile.py\fP
.IP \(bu 2
Major refactoring of C GPIO code
.IP \(bu 2
Various minor updates and fixes
.UNINDENT
.IP \(bu 2
v0.7.1
.INDENT 2.0
.IP \(bu 2
Refactoring and cleanup of c_gpio
.IP \(bu 2
Added new constants and methods (see documentation above)
.IP \(bu 2
\fBBugfixes\fP
.INDENT 2.0
.IP \(bu 2
\fBwait_for_interrupts()\fP now auto\-cleans interfaces when an exception occurs. Before you needed to call \fBRPIO.cleanup()\fP manually.
.UNINDENT
.UNINDENT
.IP \(bu 2
v0.6.4
.INDENT 2.0
.IP \(bu 2
Python 3 bugfix in \fIrpio\fP
.IP \(bu 2
Various minor updates
.UNINDENT
.UNINDENT
.SH AUTHOR
Chris Hager <chris@linuxuser.at>
.SH COPYRIGHT
2013, Chris Hager <chris@linuxuser.at>
.\" Generated by docutils manpage writer.
.
