.TH "RPIO" "1" "February 23, 2013" "0.7.1" "RPIO"
.SH NAME
rpio \- RPIO Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.\" Man page generated from reStructuredText.
.
.sp
RPIO is a GPIO toolbox for the Raspberry Pi.
.INDENT 0.0
.IP \(bu 2
\fI\%RPIO.py\fP, an extension of \fI\%RPi.GPIO\fP with interrupt handling and \fI\%more\fP
.IP \(bu 2
\fI\%rpio\fP, a command\-line multitool for inspecting and manipulating GPIOs
.UNINDENT
.sp
The easiest way to install/update RPIO on a Raspberry Pi is with either \fBeasy_install\fP or \fBpip\fP (you may need
to get it first with \fBsudo apt\-get install python\-setuptools\fP):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ sudo easy_install \-U RPIO
$ sudo pip install \-U RPIO
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Another way to get RPIO is directly from the Github repository:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ git clone https://github.com/metachris/RPIO.git
$ cd RPIO
$ sudo python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
After the installation you can use \fBimport RPIO\fP as well as the command\-line tool
\fBrpio\fP.
.sp
\fBrpio\fP allows you to inspect and manipulate GPIO\(aqs system wide, including those used by other processes.
\fBrpio\fP needs to run with superuser privileges (root), else it will restart using \fBsudo\fP. The BCM GPIO numbering
scheme is used by default.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
Show the help page:

    $ rpio \-h

Inspect the function and state of gpios (with \-i/\-\-inspect):

    $ rpio \-i 7
    $ rpio \-i 7,8,9
    $ rpio \-i 1\-9

    # Example output for \(garpio \-i 1\-9\(ga (non\-existing are ommitted):
    GPIO 2: ALT0   (1)
    GPIO 3: ALT0   (1)
    GPIO 4: INPUT  (0)
    GPIO 7: OUTPUT (0)
    GPIO 8: INPUT  (1)
    GPIO 9: INPUT  (0)

Inspect all GPIO\(aqs on this board (with \-I/\-\-inspect\-all):

    $ rpio \-I

Set GPIO 7 to \(ga1\(ga (or \(ga0\(ga) (with \-s/\-\-set):

    $ rpio \-s 7:1

    You can only write to pins that have been set up as OUTPUT. You can
    set this yourself with \(ga\-\-setoutput <gpio\-id>\(ga.

Show interrupt events on GPIOs (with \-w/\-\-wait_for_interrupts;
default edge=\(aqboth\(aq):

    $ rpio \-w 7
    $ rpio \-w 7:rising,8:falling,9
    $ rpio \-w 1\-9

Setup a pin as INPUT (optionally with pullup or \-down resistor):

    $ rpio \-\-setinput 7
    $ rpio \-\-setinput 7:pullup
    $ rpio \-\-setinput 7:pulldown

Setup a pin as OUTPUT:

    $ rpio \-\-setoutput 8

Show Raspberry Pi system info:

    $ rpio \-\-sysinfo

    # Example output:
    Model B, Revision 2.0, RAM: 256 MB, Maker: Sony
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can update the \fBRPIO\fP package to the latest version:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ rpio \-\-update\-rpio
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Install (and update) the \fBrpio\fP manpage:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
$ rpio \-\-update\-man
$ man rpio
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
RPIO.py extends \fI\%RPi.GPIO\fP with
interrupt handling and a few \fI\%other goodies\fP.
.sp
Interrupts are used to receive notifications from the kernel when GPIO state
changes occur. Advantages include minimized cpu consumption, very fast
notification times, and the ability to trigger on specific edge transitions
(\fBrising|falling|both\fP). RPIO uses the BCM GPIO numbering scheme by default. This
is an example of how to use RPIO to react on events on 3 pins by using
interrupts, each with different edge detections:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Setup logging
import logging
log_format = \(aq%(levelname)s | %(asctime)\-15s | %(message)s\(aq
logging.basicConfig(format=log_format, level=logging.DEBUG)

# Get started
import RPIO

def do_something(gpio_id, value):
    logging.info("New value for GPIO %s: %s" % (gpio_id, value))

RPIO.add_interrupt_callback(7, do_something, edge=\(aqrising\(aq)
RPIO.add_interrupt_callback(8, do_something, edge=\(aqfalling\(aq)
RPIO.add_interrupt_callback(9, do_something, edge=\(aqboth\(aq)
RPIO.wait_for_interrupts()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
If you want to receive a callback inside a Thread (which won\(aqt block anything
else on the system), set \fBthreaded_callback=True\fP when adding an interrupt\-
callback. Here is an example:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
RPIO.add_interrupt_callback(7, do_something, edge=\(aqrising\(aq, threaded_callback=True)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Make sure to double\-check the value returned from the interrupt, since it
is not necessarily corresponding to the edge (eg. 0 may come in as value,
even if \fIedge="rising"\fP). To remove all callbacks from a certain gpio pin, use
\fBRPIO.del_interrupt_callback(gpio_id)\fP. To stop the \fBwait_for_interrupts()\fP
loop you can call \fBRPIO.stop_waiting_for_interrupts()\fP.
.SH RPI.GPIO
.sp
Besides the interrupt handling, you can use RPIO just as \fI\%RPi.GPIO\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO

# set up input channel without pull\-up
RPIO.setup(7, RPIO.IN)

# set up input channel with pull\-up control
#   (pull_up_down be PUD_OFF, PUD_UP or PUD_DOWN, default PUD_OFF)
RPIO.setup(7, RPIO.IN, pull_up_down=RPIO.PUD_UP)

# read input from gpio 7
input_value = RPIO.input(7)

# set up GPIO output channel
RPIO.setup(8, RPIO.OUT)

# set gpio 8 to high
RPIO.output(8, True)

# set up output channel with an initial state
RPIO.setup(18, RPIO.OUT, initial=RPIO.LOW)

# change to BOARD numbering schema (interrupts will still use BCM though)
RPIO.setmode(RPIO.BOARD)

# reset every channel that has been set up by this program. and unexport gpio interfaces
RPIO.cleanup()
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can use RPIO as a drop\-in replacement for RPi.GPIO in your existing code like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
import RPIO as GPIO  # (if you\(aqve previously used \(gaimport RPi.GPIO as GPIO\(ga)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH ADDITIONS TO RPI.GPIO
.sp
Additional Constants
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBRPIO.RPI_REVISION\fP (either \fB1\fP or \fB2\fP)
.IP \(bu 2
\fBRPIO.RPI_REVISION_HEX\fP (\fB0002\fP .. \fB000f\fP)
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Additional Methods
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBRPIO.forceinput(gpio_id)\fP \- reads the value of any gpio without needing to call setup() first
.IP \(bu 2
\fBRPIO.forceoutput(gpio_id, value)\fP \- writes a value to any gpio without needing to call setup() first (\fBwarning\fP: this can potentially harm
your Raspberry)
.IP \(bu 2
\fBRPIO.gpio_function(gpio_id)\fP \- returns the current setup of a gpio (\fBIN, OUT, ALT0\fP)
.IP \(bu 2
\fBRPIO.is_valid_gpio_id(gpio_id)\fP \- returns True if the supplied gpio_id is valid on this board
.IP \(bu 2
\fBRPIO.rpi_sysinfo()\fP \- returns \fB(model, revision, mb\-ram and maker)\fP of this Raspberry
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Interrupt Handling
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fBRPIO.add_interrupt_callback(gpio_id, callback, edge=\(aqboth\(aq, threaded_callback=False)\fP
.IP \(bu 2
\fBRPIO.del_interrupt_callback(gpio_id)\fP
.IP \(bu 2
\fBRPIO.wait_for_interrupts(epoll_timeout=1)\fP
.IP \(bu 2
\fBRPIO.stop_waiting_for_interrupts()\fP
.IP \(bu 2
implemented with \fBepoll\fP
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
\fI\%https://github.com/metachris/RPIO\fP
.IP \(bu 2
\fI\%http://pypi.python.org/pypi/RPIO\fP
.IP \(bu 2
\fI\%http://pypi.python.org/pypi/RPi.GPIO\fP
.IP \(bu 2
\fI\%http://www.kernel.org/doc/Documentation/gpio.txt\fP
.UNINDENT
.sp
Please send any feedback to Chris Hager (\fI\%chris@linuxuser.at\fP) and \fI\%open an issue at Github\fP if
you\(aqve encountered a bug.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
RPIO is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RPIO is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
v0.7.1: Refactoring of c_gpio, added new constants and methods
.IP \(bu 2
v0.6.4: Python 3 bugfix in \fIrpio\fP
.UNINDENT
.SH AUTHOR
Chris Hager <chris@linuxuser.at>
.SH COPYRIGHT
2013, Chris Hager <chris@linuxuser.at>
.\" Generated by docutils manpage writer.
.
